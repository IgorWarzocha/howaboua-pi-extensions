{
  "id": "0a484a68",
  "title": "[Phase 2] Self-healing: No-op edit detection",
  "tags": [
    "pi-hash",
    "phase-2",
    "self-healing",
    "no-op-detection"
  ],
  "status": "closed",
  "created_at": "2026-02-12T21:25:47.687Z",
  "assigned_to_session": "5d994b6f-5c75-4f28-8a94-ed305756b8c1"
}

## Completed

No-op edit detection has been implemented in `healing.ts` and `apply.ts`.

### Implementation

1. **Added `ApplyNoop` type** (types.ts):
```typescript
export type ApplyNoop = {
  path: string;
  line: number;
  reason: string;
};
```

2. **Added `noops` to `ApplySummary`** (types.ts):
```typescript
export type ApplySummary = {
  // ... existing fields
  noops: ApplyNoop[];
};
```

3. **No-op detection in healing function** (healing.ts):
   - After applying all healing transformations, compare original vs new content
   - If identical, push to `noops` array with path, line, and reason
   - Skip applying the replacement (don't fail, just warn)

4. **Initialized `noops: []` in summary** (apply.ts):
   - Added empty array initialization in `applyHunks()`

### How It Works

When `computeReplacementsWithHealing()` detects that the healed content matches the original:
1. It adds an entry to `noops` array: `{ path, line, reason: "Replacement identical to current content" }`
2. It skips adding the replacement (no file change)
3. The patch still succeeds (warn, not fail)
4. Other real changes still apply

### Acceptance Criteria Met

- [x] Identical replacement detected as no-op
- [x] Patch still succeeds (warn, not fail)
- [x] Real changes still apply
